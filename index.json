[{"categories":["ctf-writeups"],"content":"Writeup for Pwn2Win CTF 2020, challenge name: Androids_Encryption","date":"2020-08-09","objectID":"/pwn2win2020-androids-encryption/","tags":["symmetric-crypto","aes","pwn2win-ctf","crypto"],"title":"Pwn2win2020 Androids Encryption","uri":"/pwn2win2020-androids-encryption/"},{"categories":["ctf-writeups"],"content":"Challenge Info â€‹ The challenge is a crypto challenge from the pwn2win event , itâ€™s focused on the symmetric cryptography and especially the aes block cipher.So we are given remote connection nc encryption.pwn2.win 1337 and the python script that is running in the remote server.py . ","date":"2020-08-09","objectID":"/pwn2win2020-androids-encryption/:0:1","tags":["symmetric-crypto","aes","pwn2win-ctf","crypto"],"title":"Pwn2win2020 Androids Encryption","uri":"/pwn2win2020-androids-encryption/"},{"categories":["ctf-writeups"],"content":"Writeup Summary gain general information deep look into encrypt your secret solution ","date":"2020-08-09","objectID":"/pwn2win2020-androids-encryption/:0:2","tags":["symmetric-crypto","aes","pwn2win-ctf","crypto"],"title":"Pwn2win2020 Androids Encryption","uri":"/pwn2win2020-androids-encryption/"},{"categories":["ctf-writeups"],"content":"general information â€‹ By the first look at the server.py script we notice there are 3 main functions first one is def encrypt(txt, key, iv) where you pass the plaintext the key and iv this function will check that the plaintext length is multiple of Block Size which is 128 and then it will encrypt the plaintext with custom implementation of AES , the second one is enc_plaintextthis function that we will interact with it will take our plaintext and decode it as a base64 and pass it to encrypt with key1 and iv1 which are secrets . The last function is enc_flag() it will encrypt the flag with key2 and iv2 which their difinition is : iv2 = AES.new(key1, AES.MODE_ECB).decrypt(iv1) key2 = xor(to_blocks(flag)) by looking at the xor function we noticed that if two parametres a,b are passed then it will calculate a xor b else if one parametre a is passed it will return a[0] xor \\x00 *len(a[0]) so it will return the first block xored with 00 and that meen it will return the first block . ","date":"2020-08-09","objectID":"/pwn2win2020-androids-encryption/:0:3","tags":["symmetric-crypto","aes","pwn2win-ctf","crypto"],"title":"Pwn2win2020 Androids Encryption","uri":"/pwn2win2020-androids-encryption/"},{"categories":["ctf-writeups"],"content":"deep look into encrypt your secret â€‹ After looking in the function i noticed it doing 2 things interesting : first thing is that it is returning to us the iv passed in parametre + the cipher so for example if we passed iv2 to the function than we get as a result iv2+ cipher base64.b64encode(iv+ctxt) PS: of course all inputs and outputs are encoded with base64 the second interesting thing is that it is overriding the iv2 and key2 that are used in encrypting the flag : iv2 = AES.new(key2, AES.MODE_ECB).decrypt(iv2) key2 = xor(to_blocks(ctxt)) so the new iv2 is the decryption of the previous iv2 with key2 and the new key2 is the xor of the cipher calculated and as we have discussed xor function when we pass one parametre it will return the first block of the passed object so key2 = cipher[0] so from the result iv+ctx we can get iv1 and key2 from the cipher and to get the next value of iv2 we need the value of key2 before change .so the idea of the challenge is to try to guess the iv2 and key2 that will be used next time we encrypt the flag . ","date":"2020-08-09","objectID":"/pwn2win2020-androids-encryption/:0:4","tags":["symmetric-crypto","aes","pwn2win-ctf","crypto"],"title":"Pwn2win2020 Androids Encryption","uri":"/pwn2win2020-androids-encryption/"},{"categories":["ctf-writeups"],"content":"Solution â€‹ after trying in a paper the different combination of commandes that will allow us to get the key and initial vector i finnaly found the solution it is bit tricky so what we will do is : we will send a random payload with 16 bytes to the oracle that will return us iv1 + cipher and from the cipher we can get the new value key2 because as we said key2 = a[0] the new key is the first block of cipher next we will send the encrypt flag command that will return to us iv2 + flag_cipher and here we can use the result of the first step which is key2 and get the new value of iv2 because it will be changed by iv2 = AES.new(key2, AES.MODE_ECB).decrypt(iv2) and also we update the value of key2 now we have the key2 and iv2 values and we can use it to decipher the flag next time because this value will be used next time we will send the encrypt flag command and decrypt the cipher : aes = AES.new(key2, AES.MODE_ECB) curr = iv2 bs = len(key2) text=b\"\" for block in blocks: text +=xor(curr, aes.decrypt(block)) curr = xor(text[-bs:], block) print(text) the challenge used a modified version of aes ecb it work like this cipher1 = aes(text1 xor iv) then cipher2 = aes(text2 xor (text1 xor cipher1)) and it do this for each block . so for the decryption part we can do this text1 = iv xor aes.decrypt(cipher1) and for other blocks textI= (cipherJ xor textJ) xor aes.decrypt(cipherI) where J = I-1. and finnaly we got the flag CTF-BR{kn3W_7h4T_7hEr3_4r3_Pc8C_r3pe471ti0ns?!?} . awesome challenge had so much fun solving it . â€‹ ","date":"2020-08-09","objectID":"/pwn2win2020-androids-encryption/:0:5","tags":["symmetric-crypto","aes","pwn2win-ctf","crypto"],"title":"Pwn2win2020 Androids Encryption","uri":"/pwn2win2020-androids-encryption/"},{"categories":["ctf-writeups"],"content":"Writeup for Cybrics CTF 2020, challenge name: OTP","date":"2020-08-08","objectID":"/cybrics2020-otp/","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"},{"categories":["ctf-writeups"],"content":"Challenge Info A crack the box challenge (hackthebox/vulnhub-like) http://otp-cybrics2020.ctf.su/ the web-page provides a input for auth token and a the client binary and the serverâ€™s, and the source code of the server. Main Page ","date":"2020-08-08","objectID":"/cybrics2020-otp/:1:0","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"},{"categories":["ctf-writeups"],"content":"TL-DR We discover the client binary is using ssh, we get the private key out of the binary and get the user also we use ssh keys to do forward port tunneling of the mongodb port from the server to our machine we connect to the db and get the otp of the admin provide it to the website and we get the flag. ","date":"2020-08-08","objectID":"/cybrics2020-otp/:2:0","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"},{"categories":["ctf-writeups"],"content":"Writeup Summary Understanding how the service works. Doing some blackbox analyses on the client binary. Port forwarding the mongodb port to our machine. Getting the otp from the mongodb and submitting it to get the flag. ","date":"2020-08-08","objectID":"/cybrics2020-otp/:3:0","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"},{"categories":["ctf-writeups"],"content":"Initial Understanding The client binary can be used to login or register an account, the login mechanism do itâ€™s magic and get u a token : ./client login -l user7 -p userpass7 Response: SUCCESS: ac003f82-edfc-4855-b761-bdc59406d8d4 The token can be submitted into the webpage but get nothing because weâ€™re not admin: Cabinet Page that means the admin token is the target. The server binary we can understand itâ€™s functionality from the source code, Itâ€™s expect 3 lines as input, first one is the action(login/register), the second is username, the third is password; It connects to a mongodb and create a user in case of register or verify the creds and create an otp in case of login. PS: the serverâ€™s code import mongodb configs (username,pass, host,port) from a .env file but still uses hardcoded creds, dbname and collection. ","date":"2020-08-08","objectID":"/cybrics2020-otp/:3:1","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"},{"categories":["ctf-writeups"],"content":"Blackbox Analyses Both the client and the server were written in go, we first tried reverse engineering it but we all know how messy that can be, so we tried some black box analyses, First we analyzed the network using strace : strace -f -e trace=network ./client login -l user7 -p userpass7 Strace We see the client app resolves the domain otp-cybrics2020.ctf.su and gets itâ€™s ip address 34.76.112.206 but we canâ€™t get how the data is sent, so we decide to capture the network sent to that specific ip, we used tcpdump : tcpdump -i wlp7s0 dst 34.76.112.206 -w Capture.pcap Taking a look at the capture with wireshark: Wireshark We confirmed the app is using ssh but we have no creds or ssh keys since the packets are encrypted, running strings on the app and greping for specific patterns we got ssh private keys id_rsa We need a username now, we tried guessing nothing came out, To try and get the username we modified out /etc/hosts so the challenge domain points back to our loopback address 127.0.0.1 we run the binary and the we check our ssh logs with: systemctl status sshd we got : sshd[13342]: Invalid user guest from 127.0.0.1 port 40898 The user is guest, I guess our guess work wasnâ€™t on point ðŸ˜› . Now we got everything for the ssh connection. ","date":"2020-08-08","objectID":"/cybrics2020-otp/:3:2","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"},{"categories":["ctf-writeups"],"content":"SSH session Connection to the ssh session we donâ€™t get a shell but instead a clear prompt, poking at it a little we know itâ€™s the serverâ€™s binary, we donâ€™t get much, but itâ€™s ssh and ssh has many features builtin on it, one of many is port forwarding (more on port forwarding over here ), we port forward the mongodb port 27017 since we already got the creds from the source code of the server. ssh -L 27017:localhost:27017 guest@34.76.112.206 -i id_rsa Checking open port on our machine and: tcp 0 0 127.0.0.1:27017 0.0.0.0:* LISTEN 9530/ssh Itâ€™s open. ","date":"2020-08-08","objectID":"/cybrics2020-otp/:3:3","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"},{"categories":["ctf-writeups"],"content":"Connecting to mongodb Since we already have the creds mongodb://admin:admin@localhost:27017 and the db name cybrics (Both from the source code). We can connect right to the db away : mongo -u admin -p admin --authenticationDatabase cybrics We already know the schema from the source so we right away query the admin user \u003e use cybrics switched to db cybrics \u003e db cybrics \u003e db.users.find({username : \"admin\"}) { \"_id\" : ObjectId(\"5f1ae2e97e2bd0263657b0ee\"), \"username\" : \"admin\", \"password\" : \"j77d32g72373ggasdkasdGG\u0026SD\", \"otp\" : \"f41a137f-aeb0-4518-9d20-2aafc4fcb90f\" } \u003e We get the adminâ€™s otp : f41a137f-aeb0-4518-9d20-2aafc4fcb90f We submit it in the web to get the flag: Flag Flag: cybrics{n07_S0_D1fF1cuL7_8U7_4lw4yS_chECK_P0R7_F0rw4Rd1N9} ","date":"2020-08-08","objectID":"/cybrics2020-otp/:3:4","tags":["linux","ctb","cybrics-ctf","ssh"],"title":"Cybrics2020 Otp","uri":"/cybrics2020-otp/"}]